global:
  postgresql:
    # Connection details
    host: ""  # Leave empty to use in-cluster PostgreSQL, set for external PostgreSQL
    port: "5432"
    # Authentication - use either direct values OR existingSecret
    auth:
      username: "cruisekube"
      password: "cruisekube"
      database: "cruisekube"
    # Kubernetes secret configuration (takes precedence over auth fields if set)
    existingSecret:
      name: ""  # Name of existing Kubernetes secret containing PostgreSQL credentials
      keys:
        # Keys in the secret for PostgreSQL chart
        postgresPasswordKey: ""  # Key for PostgreSQL admin password
        userPasswordKey: ""               # Key for user password
        # Keys in the secret for cruisekubeController environment variables
        hostKey: ""                  # Key for PostgreSQL host
        portKey: ""                  # Key for PostgreSQL port
        databaseKey: ""                # Key for database name
        usernameKey: ""              # Key for username
cruisekubeController:
  enabled: true
  replicas: 1
  image:
    repository: tfy.jfrog.io/tfy-images/cruisekube
    imagePullPolicy: IfNotPresent
    tag: "0.1.5"
  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""
  controller:
    mode: "inCluster"
  serviceAccount:
    create: true
    name: ""
  rbac:
    create: true
  persistence:
    enabled: true
    size: 5Gi
    storageClass: ""
    accessMode: ReadWriteOnce
    mountPath: /app/stats-data
    annotations: {}
  podAnnotations: {}
  podLabels: {}
  service:
    type: ClusterIP
    httpPort: 8080
    metricsPort: 8081
    annotations: {}
  serviceMonitor:
    enabled: true
    jobLabel: cruisekube-controller
    additionalLabels: {}
    additionalAnnotations: {}
    endpoints:
      - port: metrics
        path: /metrics
        interval: 30s
        scrapeTimeout: 10s
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi
  volumeMounts: []
  env:
    POSTGRES_HOST: "{{ .Values.global.postgresql.host }}"
    POSTGRES_PORT: "{{ .Values.global.postgresql.port }}"
    POSTGRES_DB: "{{ .Values.global.postgresql.auth.database }}"
    POSTGRES_USER: "{{ .Values.global.postgresql.auth.username }}"
    POSTGRES_PASSWORD: "{{ .Values.global.postgresql.auth.password }}"
  envFromSecret:
    - name: POSTGRES_PASSWORD
      valueFrom:
        secretKeyRef:
          name: "{{ .Values.global.postgresql.existingSecret.name }}"
          key: "{{ .Values.global.postgresql.existingSecret.keys.userPasswordKey }}"
    - name: POSTGRES_HOST
      valueFrom:
        secretKeyRef:
          name: "{{ .Values.global.postgresql.existingSecret.name }}"
          key: "{{ .Values.global.postgresql.existingSecret.keys.hostKey }}"


cruisekubeWebhook:
  enabled: true
  replicas: 1
  image:
    repository: tfy.jfrog.io/tfy-images/cruisekube
    imagePullPolicy: IfNotPresent
    tag: "0.1.5"
  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""
  webhook:
    certsDir: "/certs"
    statsURL:
      host: ""
  mutatingWebhookConfiguration:
    clusterID: "default"
    timeoutSeconds: 10
    failurePolicy: "Ignore"
    namespaceSelector:
      excludeNamespaces:
        - "kube-public"
        - "kube-node-lease"
        - "local-path-storage"
  certGen:
    enabled: true
    image:
      repository: registry.k8s.io/ingress-nginx/kube-webhook-certgen
      imagePullPolicy: IfNotPresent
      tag: v1.5.2
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 10m
        memory: 32Mi
    rbac:
      create: true
    serviceAccount:
      create: true
      name: ""
  rbac:
    create: true
  podAnnotations: {}
  podLabels: {}
  serviceAccount:
    create: true
    name: ""
  service:
    type: ClusterIP
    httpsPort: 8443
    metricsPort: 8081
    annotations: {}
  serviceMonitor:
    enabled: true
    jobLabel: cruisekube-webhook
    additionalLabels: {}
    additionalAnnotations: {}
    endpoints:
      - port: metrics
        path: /metrics
        interval: 30s
        scrapeTimeout: 10s
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi
  env: {}
postgresql:
  # Automatically disable PostgreSQL when using external secret (external database)
  enabled: "{{ if .Values.global.postgresql.existingSecret.name }}false{{ else }}true{{ end }}"
  auth:
    username: "{{ .Values.global.postgresql.auth.username }}"
    password: "{{ .Values.global.postgresql.auth.password }}"
    database: "{{ .Values.global.postgresql.auth.database }}"
    existingSecret: "{{ .Values.global.postgresql.existingSecret.name }}"
    secretKeys:
      userPasswordKey: "{{ .Values.global.postgresql.existingSecret.keys.userPasswordKey }}"
  primary:
    persistence:
      enabled: true
      size: 2Gi
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 128Mi
